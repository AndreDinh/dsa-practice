// problems.js - Additional problems to be loaded by index.html

window.additionalProblems = [
    // Arrays (4 more)
    { id: 2, category: "Arrays", difficulty: "medium", title: "Two Sum with Hash Map", description: "The Two Sum problem asks you to find two numbers that add up to a target. Using a hash map makes this O(n) instead of O(n²).", items: ["const map = new Map();", "for (let i = 0; i < nums.length; i++) {", "  const complement = target - nums[i];", "  if (map.has(complement)) return [map.get(complement), i];", "  map.set(nums[i], i);", "}"], answer: [0, 1, 2, 3, 4, 5], hint: "Initialize map first, then loop and check" },
    { id: 3, category: "Arrays", difficulty: "medium", title: "Kadane's Algorithm", description: "Kadane's Algorithm finds the maximum sum of any contiguous subarray in linear time O(n).", items: ["let maxSum = nums[0], currentSum = nums[0];", "for (let i = 1; i < nums.length; i++) {", "  currentSum = Math.max(nums[i], currentSum + nums[i]);", "  maxSum = Math.max(maxSum, currentSum);", "}", "return maxSum;"], answer: [0, 1, 2, 3, 4, 5], hint: "Track current and max sums" },
    { id: 4, category: "Arrays", difficulty: "medium", title: "Merge Two Sorted Arrays", description: "Given two sorted arrays, merge them into one sorted array using two pointers.", items: ["let i = 0, j = 0, result = [];", "while (i < arr1.length && j < arr2.length) {", "  if (arr1[i] < arr2[j]) result.push(arr1[i++]);", "  else result.push(arr2[j++]);", "}", "return result.concat(arr1.slice(i)).concat(arr2.slice(j));"], answer: [0, 1, 2, 3, 4, 5], hint: "Two pointers, then append remaining" },
    { id: 5, category: "Arrays", difficulty: "hard", title: "Trapping Rain Water", description: "Calculate how much rain water can be trapped between bars. Use two pointers from both ends.", items: ["let left = 0, right = nums.length - 1;", "let maxLeft = 0, maxRight = 0, water = 0;", "while (left < right) {", "  if (nums[left] < nums[right]) {", "    maxLeft = Math.max(maxLeft, nums[left]);", "    water += maxLeft - nums[left++];", "  } else {", "    maxRight = Math.max(maxRight, nums[right]);", "    water += maxRight - nums[right--];", "  }", "}", "return water;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], hint: "Compare boundaries from both ends" },
    { id: 6, category: "Arrays", difficulty: "medium", title: "Rotate Array Right", description: "Rotate an array to the right by k positions using three array reversals.", items: ["k = k % nums.length;", "reverse(nums, 0, nums.length - 1);", "reverse(nums, 0, k - 1);", "reverse(nums, k, nums.length - 1);"], answer: [0, 1, 2, 3], hint: "Normalize k, then three reversals" },
    { id: 7, category: "Arrays", difficulty: "medium", title: "Remove Duplicates In-Place", description: "Remove duplicates from a sorted array in-place using two pointers.", items: ["if (nums.length === 0) return 0;", "let j = 0;", "for (let i = 1; i < nums.length; i++) {", "  if (nums[i] !== nums[j]) {", "    j++;", "    nums[j] = nums[i];", "  }", "}", "return j + 1;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8], hint: "Use slow pointer j to track unique position" },

    // Linked Lists (4 more)
    { id: 9, category: "Linked Lists", difficulty: "medium", title: "Detect Cycle (Floyd's Algorithm)", description: "Detect if a linked list has a cycle using Floyd's tortoise and hare algorithm.", items: ["let slow = head, fast = head;", "while (fast && fast.next) {", "  slow = slow.next;", "  fast = fast.next.next;", "  if (slow === fast) return true;", "}", "return false;"], answer: [0, 1, 2, 3, 4, 5, 6], hint: "Fast moves twice as fast" },
    { id: 10, category: "Linked Lists", difficulty: "medium", title: "Merge Two Sorted Lists", description: "Merge two sorted linked lists using a dummy node.", items: ["let dummy = new ListNode(0);", "let tail = dummy;", "while (l1 && l2) {", "  if (l1.val < l2.val) {", "    tail.next = l1;", "    l1 = l1.next;", "  } else {", "    tail.next = l2;", "    l2 = l2.next;", "  }", "  tail = tail.next;", "}", "tail.next = l1 || l2;", "return dummy.next;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], hint: "Use dummy node to simplify" },
    { id: 11, category: "Linked Lists", difficulty: "medium", title: "Remove Nth Node From End", description: "Remove the nth node from the end using two pointers with a gap of n.", items: ["let dummy = new ListNode(0, head);", "let first = dummy, second = dummy;", "for (let i = 0; i <= n; i++) first = first.next;", "while (first) {", "  first = first.next;", "  second = second.next;", "}", "second.next = second.next.next;", "return dummy.next;"], answer: [0, 1, 2, 3, 4, 5, 6, 7], hint: "Gap of n between pointers" },
    { id: 12, category: "Linked Lists", difficulty: "hard", title: "Reverse Nodes in K-Group", description: "Reverse nodes in groups of k combining reversal with recursion.", items: ["let count = 0, curr = head;", "while (curr && count < k) { curr = curr.next; count++; }", "if (count < k) return head;", "curr = head; let prev = null;", "for (let i = 0; i < k; i++) {", "  let next = curr.next;", "  curr.next = prev;", "  prev = curr;", "  curr = next;", "}", "head.next = reverseKGroup(curr, k);", "return prev;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], hint: "Check k nodes exist, reverse, recurse" },

    // Stacks & Queues (5)
    { id: 13, category: "Stacks", difficulty: "easy", title: "Valid Parentheses", description: "Check if parentheses are valid using a stack.", items: ["const stack = [];", "const map = { ')': '(', '}': '{', ']': '[' };", "for (let char of s) {", "  if (char in map) {", "    if (stack.pop() !== map[char]) return false;", "  } else stack.push(char);", "}", "return stack.length === 0;"], answer: [0, 1, 2, 3, 4, 5, 6, 7], hint: "Push open, pop and match close" },
    { id: 14, category: "Stacks", difficulty: "medium", title: "Min Stack Implementation", description: "Design a stack that supports push, pop, top, and min in O(1) time using two stacks.", items: ["constructor() { this.stack = []; this.minStack = []; }", "push(val) {", "  this.stack.push(val);", "  const min = this.minStack.length ? Math.min(val, this.getMin()) : val;", "  this.minStack.push(min);", "}", "pop() { this.stack.pop(); this.minStack.pop(); }", "getMin() { return this.minStack[this.minStack.length - 1]; }"], answer: [0, 1, 2, 3, 4, 5, 6, 7], hint: "Track min at each level" },
    { id: 15, category: "Stacks", difficulty: "medium", title: "Evaluate Reverse Polish Notation", description: "Evaluate arithmetic expression in RPN using a stack.", items: ["const stack = [];", "const ops = { '+': (a,b) => a+b, '-': (a,b) => a-b, '*': (a,b) => a*b, '/': (a,b) => Math.trunc(a/b) };", "for (let token of tokens) {", "  if (token in ops) {", "    const b = stack.pop(), a = stack.pop();", "    stack.push(ops[token](a, b));", "  } else stack.push(Number(token));", "}", "return stack[0];"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8], hint: "Operators pop two, compute, push" },
    { id: 16, category: "Queues", difficulty: "medium", title: "Sliding Window Maximum", description: "Find maximum in each sliding window using a deque.", items: ["const deque = [], result = [];", "for (let i = 0; i < nums.length; i++) {", "  while (deque.length && deque[0] < i - k + 1) deque.shift();", "  while (deque.length && nums[deque[deque.length-1]] < nums[i]) deque.pop();", "  deque.push(i);", "  if (i >= k - 1) result.push(nums[deque[0]]);", "}", "return result;"], answer: [0, 1, 2, 3, 4, 5, 6, 7], hint: "Deque maintains decreasing values" },
    { id: 17, category: "Stacks", difficulty: "hard", title: "Largest Rectangle in Histogram", description: "Find largest rectangle using monotonic stack.", items: ["const stack = [];", "let maxArea = 0;", "for (let i = 0; i < heights.length; i++) {", "  while (stack.length && heights[i] < heights[stack[stack.length-1]]) {", "    const h = heights[stack.pop()];", "    const w = stack.length ? i - stack[stack.length-1] - 1 : i;", "    maxArea = Math.max(maxArea, h * w);", "  }", "  stack.push(i);", "}", "return maxArea;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], hint: "Stack maintains increasing heights" },

    // Trees (5)
    { id: 18, category: "Trees", difficulty: "easy", title: "Inorder Traversal", description: "Perform inorder traversal (Left → Root → Right) recursively.", items: ["function inorder(node, result = []) {", "  if (!node) return result;", "  inorder(node.left, result);", "  result.push(node.val);", "  inorder(node.right, result);", "  return result;", "}"], answer: [0, 1, 2, 3, 4, 5, 6], hint: "Left → Root → Right" },
    { id: 19, category: "Trees", difficulty: "medium", title: "Level Order Traversal (BFS)", description: "Traverse tree level by level using BFS with a queue.", items: ["const queue = [root], result = [];", "while (queue.length) {", "  const level = [];", "  const size = queue.length;", "  for (let i = 0; i < size; i++) {", "    const node = queue.shift();", "    level.push(node.val);", "    if (node.left) queue.push(node.left);", "    if (node.right) queue.push(node.right);", "  }", "  result.push(level);", "}", "return result;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], hint: "Process level by level with queue" },
    { id: 20, category: "Trees", difficulty: "medium", title: "Validate Binary Search Tree", description: "Check if tree is a valid BST by passing range constraints.", items: ["function isValid(node, min = -Infinity, max = Infinity) {", "  if (!node) return true;", "  if (node.val <= min || node.val >= max) return false;", "  return isValid(node.left, min, node.val) &&", "         isValid(node.right, node.val, max);", "}"], answer: [0, 1, 2, 3, 4, 5], hint: "Each node constrained by range from ancestors" },
    { id: 21, category: "Trees", difficulty: "medium", title: "Lowest Common Ancestor", description: "Find LCA - the deepest node with both p and q as descendants.", items: ["if (!root || root === p || root === q) return root;", "const left = lowestCommonAncestor(root.left, p, q);", "const right = lowestCommonAncestor(root.right, p, q);", "if (left && right) return root;", "return left || right;"], answer: [0, 1, 2, 3, 4], hint: "Found in both subtrees? Root is LCA" },
    { id: 22, category: "Trees", difficulty: "hard", title: "Serialize and Deserialize Binary Tree", description: "Convert tree to string and back using preorder with null markers.", items: ["serialize(root) {", "  if (!root) return 'null';", "  return root.val + ',' + this.serialize(root.left) + ',' + this.serialize(root.right);", "}", "deserialize(data) {", "  const vals = data.split(',');", "  return this.buildTree(vals);", "}"], answer: [0, 1, 2, 3, 4, 5, 6, 7], hint: "Preorder with null markers captures structure" },

    // Graphs (4)
    { id: 23, category: "Graphs", difficulty: "medium", title: "Depth First Search", description: "Traverse graph using recursive DFS.", items: ["function dfs(node, visited = new Set()) {", "  if (visited.has(node)) return;", "  visited.add(node);", "  console.log(node);", "  for (let neighbor of graph[node]) {", "    dfs(neighbor, visited);", "  }", "}"], answer: [0, 1, 2, 3, 4, 5, 6, 7], hint: "Mark visited, recurse on neighbors" },
    { id: 24, category: "Graphs", difficulty: "medium", title: "Breadth First Search", description: "Traverse graph using BFS with queue.", items: ["const queue = [start], visited = new Set([start]);", "while (queue.length) {", "  const node = queue.shift();", "  console.log(node);", "  for (let neighbor of graph[node]) {", "    if (!visited.has(neighbor)) {", "      visited.add(neighbor);", "      queue.push(neighbor);", "    }", "  }", "}"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], hint: "Queue for level-by-level exploration" },
    { id: 25, category: "Graphs", difficulty: "hard", title: "Topological Sort", description: "Order nodes in DAG using DFS-based topological sort.", items: ["const visited = new Set(), stack = [];", "function dfs(node) {", "  if (visited.has(node)) return;", "  visited.add(node);", "  for (let neighbor of graph[node]) dfs(neighbor);", "  stack.push(node);", "}", "for (let node of nodes) dfs(node);", "return stack.reverse();"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8], hint: "Push after visiting children, then reverse" },
    { id: 26, category: "Graphs", difficulty: "hard", title: "Dijkstra's Shortest Path", description: "Find shortest paths using greedy algorithm with priority queue.", items: ["const dist = new Array(n).fill(Infinity);", "dist[start] = 0;", "const pq = new MinPriorityQueue();", "pq.enqueue(start, 0);", "while (!pq.isEmpty()) {", "  const {element: node} = pq.dequeue();", "  for (let [neighbor, weight] of graph[node]) {", "    const newDist = dist[node] + weight;", "    if (newDist < dist[neighbor]) {", "      dist[neighbor] = newDist;", "      pq.enqueue(neighbor, newDist);", "    }", "  }", "}", "return dist;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], hint: "Priority queue selects minimum distance greedily" },

    // Dynamic Programming (4)
    { id: 27, category: "DP", difficulty: "easy", title: "Fibonacci with DP", description: "Calculate nth Fibonacci using bottom-up DP.", items: ["const dp = [0, 1];", "for (let i = 2; i <= n; i++) {", "  dp[i] = dp[i-1] + dp[i-2];", "}", "return dp[n];"], answer: [0, 1, 2, 3, 4], hint: "Build solution from base cases upward" },
    { id: 28, category: "DP", difficulty: "medium", title: "Coin Change", description: "Find minimum coins needed for amount using DP.", items: ["const dp = new Array(amount + 1).fill(Infinity);", "dp[0] = 0;", "for (let coin of coins) {", "  for (let i = coin; i <= amount; i++) {", "    dp[i] = Math.min(dp[i], dp[i - coin] + 1);", "  }", "}", "return dp[amount] === Infinity ? -1 : dp[amount];"], answer: [0, 1, 2, 3, 4, 5, 6, 7], hint: "Try all coins for each amount" },
    { id: 29, category: "DP", difficulty: "medium", title: "Longest Increasing Subsequence", description: "Find length of LIS using DP.", items: ["const dp = new Array(nums.length).fill(1);", "for (let i = 1; i < nums.length; i++) {", "  for (let j = 0; j < i; j++) {", "    if (nums[j] < nums[i]) {", "      dp[i] = Math.max(dp[i], dp[j] + 1);", "    }", "  }", "}", "return Math.max(...dp);"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8], hint: "Each element can extend previous subsequences" },
    { id: 30, category: "DP", difficulty: "hard", title: "Edit Distance", description: "Find minimum operations to convert one string to another using 2D DP.", items: ["const dp = Array(m+1).fill(0).map(() => Array(n+1).fill(0));", "for (let i = 0; i <= m; i++) dp[i][0] = i;", "for (let j = 0; j <= n; j++) dp[0][j] = j;", "for (let i = 1; i <= m; i++) {", "  for (let j = 1; j <= n; j++) {", "    if (word1[i-1] === word2[j-1]) dp[i][j] = dp[i-1][j-1];", "    else dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);", "  }", "}", "return dp[m][n];"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], hint: "2D table compares every character pair" },

    // React (9 more)
    { id: 32, category: "React", difficulty: "medium", title: "useEffect with Cleanup", description: "Use useEffect with cleanup function for timers.", items: ["import { useEffect } from 'react';", "useEffect(() => {", "  const timer = setInterval(() => {", "    console.log('tick');", "  }, 1000);", "  return () => clearInterval(timer);", "}, []);"], answer: [0, 1, 2, 3, 4, 5, 6], hint: "Effect runs after render, cleanup prevents leaks" },
    { id: 33, category: "React", difficulty: "medium", title: "Controlled Form Input", description: "Create controlled component with React state.", items: ["const [value, setValue] = useState('');", "const handleChange = (e) => setValue(e.target.value);", "return <input", "  value={value}", "  onChange={handleChange}", "/>;"], answer: [0, 1, 2, 3, 4, 5], hint: "State is single source of truth" },
    { id: 34, category: "React", difficulty: "medium", title: "useContext Hook", description: "Use Context API to avoid props drilling.", items: ["const ThemeContext = React.createContext('light');", "function App() {", "  return <ThemeContext.Provider value='dark'>", "    <Toolbar />", "  </ThemeContext.Provider>;", "}", "function Toolbar() {", "  const theme = useContext(ThemeContext);", "  return <div>Theme: {theme}</div>;", "}"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], hint: "Create context, provide value, consume with useContext" },
    { id: 35, category: "React", difficulty: "hard", title: "useReducer Hook", description: "Use useReducer for complex state management.", items: ["const reducer = (state, action) => {", "  switch (action.type) {", "    case 'increment': return {count: state.count + 1};", "    case 'decrement': return {count: state.count - 1};", "    default: return state;", "  }", "};", "const [state, dispatch] = useReducer(reducer, {count: 0});", "dispatch({type: 'increment'});"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8], hint: "Reducer handles multiple action types" },
    { id: 36, category: "React", difficulty: "medium", title: "Custom Hook", description: "Create reusable custom hook.", items: ["function useCounter(initial = 0) {", "  const [count, setCount] = useState(initial);", "  const increment = () => setCount(c => c + 1);", "  const decrement = () => setCount(c => c - 1);", "  return { count, increment, decrement };", "}", "const { count, increment } = useCounter(10);"], answer: [0, 1, 2, 3, 4, 5, 6], hint: "Name starts with 'use', returns state and functions" },
    { id: 37, category: "React", difficulty: "hard", title: "useMemo Hook", description: "Memoize expensive calculations with useMemo.", items: ["import { useMemo } from 'react';", "const expensiveValue = useMemo(() => {", "  return computeExpensiveValue(a, b);", "}, [a, b]);", "return <div>{expensiveValue}</div>;"], answer: [0, 1, 2, 3, 4], hint: "Memoizes result, only recomputes when deps change" },
    { id: 38, category: "React", difficulty: "hard", title: "useCallback Hook", description: "Memoize function references with useCallback.", items: ["import { useCallback } from 'react';", "const handleClick = useCallback(() => {", "  console.log(value);", "}, [value]);", "return <Child onClick={handleClick} />;"], answer: [0, 1, 2, 3, 4], hint: "Keeps same function reference unless deps change" },
    { id: 39, category: "React", difficulty: "medium", title: "React.memo", description: "Prevent re-renders with React.memo.", items: ["import { memo } from 'react';", "const ExpensiveComponent = ({data}) => {", "  return <div>{/* expensive render */}</div>;", "};", "export default memo(ExpensiveComponent);"], answer: [0, 1, 2, 3, 4], hint: "Wrapping with memo prevents re-renders on same props" },
    { id: 40, category: "React", difficulty: "hard", title: "useRef Hook", description: "Access DOM elements directly with useRef.", items: ["import { useRef, useEffect } from 'react';", "const inputRef = useRef(null);", "useEffect(() => {", "  inputRef.current.focus();", "}, []);", "return <input ref={inputRef} />;"], answer: [0, 1, 2, 3, 4, 5], hint: "Ref gives direct DOM access without re-rendering" },

    // Hash Tables (3)
    { id: 41, category: "Hash Tables", difficulty: "easy", title: "First Unique Character", description: "Find first non-repeating character using hash table.", items: ["const freq = {};", "for (let char of s) freq[char] = (freq[char] || 0) + 1;", "for (let i = 0; i < s.length; i++) {", "  if (freq[s[i]] === 1) return i;", "}", "return -1;"], answer: [0, 1, 2, 3, 4, 5], hint: "First pass counts, second finds first unique" },
    { id: 42, category: "Hash Tables", difficulty: "medium", title: "Group Anagrams", description: "Group anagrams using sorted string as key.", items: ["const map = new Map();", "for (let word of strs) {", "  const key = word.split('').sort().join('');", "  if (!map.has(key)) map.set(key, []);", "  map.get(key).push(word);", "}", "return Array.from(map.values());"], answer: [0, 1, 2, 3, 4, 5, 6], hint: "Sorted string is same for all anagrams" },
    { id: 43, category: "Hash Tables", difficulty: "hard", title: "Longest Consecutive Sequence", description: "Find longest consecutive sequence in O(n) using hash set.", items: ["const set = new Set(nums);", "let maxLen = 0;", "for (let num of set) {", "  if (!set.has(num - 1)) {", "    let curr = num, len = 1;", "    while (set.has(curr + 1)) { curr++; len++; }", "    maxLen = Math.max(maxLen, len);", "  }", "}", "return maxLen;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], hint: "Only start counting from sequence beginnings" },

    // Sorting (3)
    { id: 44, category: "Sorting", difficulty: "easy", title: "Bubble Sort", description: "Implement bubble sort algorithm.", items: ["for (let i = 0; i < arr.length - 1; i++) {", "  for (let j = 0; j < arr.length - i - 1; j++) {", "    if (arr[j] > arr[j + 1]) {", "      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];", "    }", "  }", "}"], answer: [0, 1, 2, 3, 4, 5, 6], hint: "Nested loops, compare and swap adjacent" },
    { id: 45, category: "Sorting", difficulty: "medium", title: "Merge Sort", description: "Implement merge sort using divide-and-conquer.", items: ["function mergeSort(arr) {", "  if (arr.length <= 1) return arr;", "  const mid = Math.floor(arr.length / 2);", "  const left = mergeSort(arr.slice(0, mid));", "  const right = mergeSort(arr.slice(mid));", "  return merge(left, right);", "}"], answer: [0, 1, 2, 3, 4, 5, 6], hint: "Base case size 1, recursively divide, then merge" },
    { id: 46, category: "Sorting", difficulty: "hard", title: "Quick Sort Partition", description: "Implement partition function for quicksort.", items: ["function partition(arr, low, high) {", "  const pivot = arr[high];", "  let i = low - 1;", "  for (let j = low; j < high; j++) {", "    if (arr[j] < pivot) {", "      i++;", "      [arr[i], arr[j]] = [arr[j], arr[i]];", "    }", "  }", "  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];", "  return i + 1;", "}"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], hint: "Pivot at end, partition smaller left" },

    // Heaps (2)
    { id: 47, category: "Heaps", difficulty: "medium", title: "Kth Largest Element", description: "Find kth largest using min heap of size k.", items: ["const minHeap = new MinPriorityQueue();", "for (let num of nums) {", "  minHeap.enqueue(num);", "  if (minHeap.size() > k) minHeap.dequeue();", "}", "return minHeap.front().element;"], answer: [0, 1, 2, 3, 4, 5], hint: "Min heap of size k keeps k largest" },
    { id: 48, category: "Heaps", difficulty: "hard", title: "Merge K Sorted Lists", description: "Merge k sorted lists using min heap.", items: ["const minHeap = new MinPriorityQueue((a) => a.val);", "for (let list of lists) if (list) minHeap.enqueue(list);", "const dummy = new ListNode(0);", "let tail = dummy;", "while (!minHeap.isEmpty()) {", "  const node = minHeap.dequeue().element;", "  tail.next = node;", "  tail = tail.next;", "  if (node.next) minHeap.enqueue(node.next);", "}", "return dummy.next;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], hint: "Heap always has minimum across all k lists" },

    // Strings (2)
    { id: 49, category: "Strings", difficulty: "medium", title: "Longest Substring Without Repeating", description: "Find longest substring without repeating chars using sliding window.", items: ["let left = 0, maxLen = 0;", "const seen = new Set();", "for (let right = 0; right < s.length; right++) {", "  while (seen.has(s[right])) {", "    seen.delete(s[left++]);", "  }", "  seen.add(s[right]);", "  maxLen = Math.max(maxLen, right - left + 1);", "}", "return maxLen;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], hint: "Sliding window: expand right, shrink left on duplicate" },
    { id: 50, category: "Strings", difficulty: "hard", title: "Minimum Window Substring", description: "Find minimum window containing all characters from t.", items: ["const need = new Map(), have = new Map();", "for (let c of t) need.set(c, (need.get(c) || 0) + 1);", "let left = 0, formed = 0, minLen = Infinity, result = '';", "for (let right = 0; right < s.length; right++) {", "  // expand window, track formed", "  while (formed === need.size) {", "    // contract window, update result", "  }", "}", "return result;"], answer: [0, 1, 2, 3, 4, 5, 6, 7, 8], hint: "Expand until found, contract to find minimum" }
];